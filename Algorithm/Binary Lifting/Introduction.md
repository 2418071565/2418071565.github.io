## **定义**

倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。

## **应用**

倍增最常见的应用就是求最近公共祖先$(LCA)$问题和区间最值问题$(RMQ)$

## $LCA$

### **朴素算法**

先将两个节点移动到同一层，然后让两个节点一步一步向上跳，直到两点相遇，时间复杂度为树的高度$O(\lg h)$

## **倍增**

倍增是对朴素算法的优化，从原来的一步一步跳变为每次跳$2^j$ 步。

倍增算法分为两步，第一步求$dp$数组，$dp[i][j]$代表第$i$个元素的第$2^j$个祖先，利用$dfs$初始化出，$dp$数组，时间复杂度为$O(n)$，每个节点最多只记录$\lg n$个节点，可以将查询的时间复杂度降为$O({\lg h})$。进一步分析，我们发现，第$i$个节点的$2^j$个祖先是$i$的第$2{j-1}$个祖先的$2^{j-1}$个祖先，由此我们可以写出递推公式：

$$
dp[i][j]=dp[dp[i][j-1]][j-1]
$$

第二部就是求最小公共祖先，这个步骤又可以分为两个步骤，先将两个节点移动到同一层节点中，移动过程与快速幂类似，就不赘述了。第二步就是将两个节点一起上移，我们从能走的最大$j$开始尝试，如果移动后两点还未重合，就移动，否则就减小$j$，一直尝试到$0$（包含$0$），这时他们的父节点就是最近公共祖先



## $RMQ$


## 简介
ST表(Sparse Table，稀疏表)是一种利用倍增思想来处理可重复贡献问题的数据结构。

>可重复贡献问题：$x\space opt\space x=x$，即对于问题的答案，不会因多计算几次$x$，而改变，例如$MRQ$问题、区间$gcd$问题，他们满足$max(x,x)=x$，$gcd(x,x)=x$。另外$opt$操作要满足结合律，即运算的顺序不会对最终结果产生影响。

#### [【模板】ST 表](https://www.luogu.com.cn/problem/P3865)

该模板是一个经典的$MRQ$问题。

暴力做法的话就是每次查询都遍历区间$[l,r]$，来求最大值，这样很显然会超时。

### 倍增
我们只记录区间$[i,2^j]$的最大值，这样可以用$O(n\lg n)$的时间复杂度来预处理，每次查询的时间复杂度就是$O(\lg n)$。我们用表$st[i][j]$来表示$[i,2^j]$的区间最大值，初始状态是：
$$
st[i][0]=a_i
$$
根据定义我们很容易写出倍增的递推公式
$$
st[i][j]=max\{ st[i][j-1],st[i+2^{j-1}][j-1]\} 
$$
查询的过程就和$LCA$问题类似，我们利用$ST$表从$l$移动到$r$即可。