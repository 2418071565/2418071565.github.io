既然是取 min，那么从高位往低位看，找到第一个异或不同的比特位。
例如在某个比特位上 a[i] b[i] a[j] b[j] 分别为 0 0 0 1（或者 0 1 0 0），那么后面就不用比了，a[i] ⊕ a[j] 更小，把 a[i] ⊕ a[j] 的贡献加到答案中。
怎么算贡献？对于这个比特位，把满足「a[i]=0 且 b[i]=0」的 a[i] 分到一组（记作 P），把满足「a[i]=0 且 b[i]=1」的 a[i] 分到另一组（记作 Q）。
枚举 k=0~17，那么 ∑((P 中第 k 个比特位是 1 的元素个数) * (Q 中第 k 个比特位是 0 的元素个数) + (P 中第 k 个比特位是 0 的元素个数) * (Q 中第 k 个比特位是 1 的元素个数)) * 2^k 就是贡献。

一般地，根据【a[i] 当前比特位 = 0/1】和【b[i] 当前比特位 = 0/1】，分成四组：

(0,0)：表示【a[i] 当前比特位 = 0】和【b[i] 当前比特位 = 0】
(0,1)：表示【a[i] 当前比特位 = 0】和【b[i] 当前比特位 = 1】
(1,0)：表示【a[i] 当前比特位 = 1】和【b[i] 当前比特位 = 0】
(1,1)：表示【a[i] 当前比特位 = 1】和【b[i] 当前比特位 = 1】

这四组两两之间再组合，有 C(4,2)=6 种情况：

(0,0) 和 (0,1)：表示 a[i] b[i] a[j] b[j] 分别为 0 0 0 1（或者 0 1 0 0），把 a[i] ⊕ a[j] 的贡献加到答案中。
(1,0) 和 (1,1)：同上，把 a[i] ⊕ a[j] 的贡献加到答案中。
(0,0) 和 (1,0)：表示 a[i] b[i] a[j] b[j] 分别为 0 0 1 0（或者 1 0 0 0），把 b[i] ⊕ b[j] 的贡献加到答案中。
(0,1) 和 (1,1)：同上，把 b[i] ⊕ b[j] 的贡献加到答案中。
(0,0) 和 (1,1)：这两组合并在一起，继续枚举更低的比特位。这可以递归解决。
(0,1) 和 (1,0)：这两组合并在一起，继续枚举更低的比特位。这可以递归解决。

递归边界：当前比特位等于 -1，表示当前这个组中所有 a[i] 均等于 b[i]，那么直接计算 a[i] ⊕ a[j] 的贡献。

时间复杂度：O(n* 18 *18)
