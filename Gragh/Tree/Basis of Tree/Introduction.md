## 树基础
**定义**：树是一个特殊的图，就是没有环的连通图。

一棵树有一下特点：
- 树根。基于有向图的树，有且只有一个树根；基于无向图的树，任意节点都可以作为树的树根。
- 一个有$n$个节点的树，有$n-1$条边。
- 连通性。从根除法能够到任意节点。
- 去掉一条边时，树被分成不连通的两颗树。
- 在树中任意添加一条边，就会出现环。
- 从根出发到一个节点，有且只有一条边。

# 树的重心


## 定义：
树的重心是一个节点，该节点被定为：如果节点$u$为树根，其所有子树中节点数最大的子树，比其他任意节点为根时的最大子树的节点数都少，那么$u$被称为该树的重心。

## 性质
树重心的**性质**：
- 树的重心如果不唯一，则至多有两个，且这两个重心相邻
- 一个点是重心，等价于，以这个点为根，它的每个子树的大小，都不会超过整个树大小的一半。
- 树中所有点到某个点的距离和中，到重心的距离和是最小的。如果有两个重心，那么到它们的距离和一样。更进一步，距离和最小与是重心等价。
- 如果一个树增添，或删去一个叶子，则整个树的同一个重心最多移动一个节点。
- 通过连接一条端点分别在两个树的边，来将两个树合并成一个，那么新的重心肯定是在原来这两个树的重心的路径上。

## 找重心

我们用$DFS$的方式找一棵树的重心，以下面的题目为例：[Godfather](http://poj.org/problem?id=3107)

题目中要求最大子树最小，就是找重心。

我们从任意一节点开始遍历整棵树。在遍历过程中求每个位置为根时其最大子树的大小。


<div align="center"><img src="img/01.png"width="750"></div>

每个节点为根时，其子树有蓝色和紫色框出的部分。
蓝色部分可以$DFS$下去得到，紫色部分我们可通过整个的节点个数$n$减去蓝色部分和当前节点得到。那么以当前节点为根节点的最大子树就是蓝色部分中最大子树和紫色部分中较大的一个。

我们用一个数组$d[]$记录每个节点$DFS$过程的子节点个数，即蓝色框出的节点个数。
### DFS
```cpp
void dfs(int u, int fa)
{
	d[u] = 1;
	int t = 0;
	for (int i = head[u]; ~i; i = edge[i].nxt) //链式前向星存储方式
	{
		int v = edge[i].to;
		if (v == fa)continue;    //不回到父节点
		dfs(v,u);                //计算蓝色部分节点个数
		d[u] += d[v];   
		t = max(t, d[v]);        //记录蓝色部分中最大的子树
	}
	t = max(t, n - d[u]);           //得到当前位置的最大子树
	if (t < ma)                     // 记录答案
	{
		cnt = 1;
		ans[cnt] = u;
		ma = t;
	}
	else if (t == ma)ans[++cnt] = u;
}
```

# 树的直径

树的直径是指树上最远两点之间的距离，又称为树的最远点对。

## 求树的直径

### $DFS$或$BFS$

我们从任意节点开始，通过 $dfs$ 或 $bfs$ 找到距离当前节点最远的节点，这个节点就是直径上其中一个节点，我们再从这个节点再进行一次 $dfs$ 或 $bfs$ 就可以找到直径的另一个端点。

### 树形$DP$






