

## **简介**

TCP全称为 传输控制协议(Transmission Control Protocol)。

TCP 是有连接面向字节流的全双工的可靠传输传输层通信协议。

- 面向连接：在通过 TCP 进行信息交换时，必须先建立连接。且连接是一对一的，一个连接只能用于一组计算机的信息交换。

- 可靠：保证数据的无差错、不丢失、不重复、按序到达。

- 字节流：将应用程序的数据看作一个连续的字节流，而不是离散的数据包。也就是说，在 TCP 的视角下，发送和接收的数据是一串无结构的字节，这些字节在传输过程中可以被分成多个 TCP 段（segment），但在接收端会重新组装成原始的字节流。


## **协议格式**

<figure markdown="span">
  ![Image title](./02.png){ width="500" }
</figure>

- **源端口号、目标端口号**：同 UDP。

- **序列号、确认序列号**：这两个字段用于实现 TCP 的确认应答机制，后文详细介绍。

- **首部长度**：标识了 TCP Header 的长度，单位是 4Byte，也就是 32bit。

- **控制位**：

URG（Urgent）：该位为 1 时，表示该报文为紧急报文，紧急指针有效（紧急指针标识了紧急数据在有效载荷中的偏移量），TCP 会从数据流中分离出紧急数据并立即传递给应用程序。

ACK（Acknowledgment）：该位为 1 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。

PSH（Push）：要求接收方立即将数据推送给应用程序，而不是在缓冲区中等待。

RST（Reset）：该位为 1 时，表示连接中断或发生严重错误，需要立即重新连接。当接收到 RST 标志时，接收方会立即终止连接，并且不会进行任何重传或重试操作。

SYN（Synchronize）：该位为 1 时，表示同步序列号，希望建立连接，并在其序列号的字段进行序列号初始值的设定。

FIN（Finish）：该位为 1 时，表示发送方已经完成发送数据，请求关闭连接。

- **窗口大小**：接收窗口是接收方告诉发送方可以接收的最大字节数。这是 TCP 流量控制机制的一部分，用于防止发送方发送的数据超过接收方的处理能力。

- **校验和**：同 UDP。

- **紧急指针**：同上文 URG 中的介绍。

- **选项**：最大 40Byte，这里先跳过。


## **可靠传输**

### **确认应答**

TCP 协议为了确保数据被接受方收到，接收方每收到一份数据都要告知发送方，我接收到了该数据。

发送方可能一次发送若干个数据包。为了避免接收方接收的数据乱序，发送方要将每个数据包按顺序标号，也就是 TCP 头部中的序列号。

为了能告知发送方，接收方已经正确接收的数据包，返回的确认信号中要包含确认数据的标号，也就是确认序列号。这里确认序列号表示的是：下一次接收方期望收到的，确认序列号之前的所有数据已经被接收方收到了。

??? note "为什么报文序列号和确认序列号是两个字段？"
    **问题：**我们明明可以通过 ACK 字段，来区分报文是确认报文还是数据报文，为什么还要把序列号划分位两个字段，这样增加了数据的长度，不会造成网络资源的浪费吗？

    **回答：**TCP 是一种全双工的通信方式，当接收方在接收数据的同时，也会发送数据，如果用 ACK 将确认报文和数据报文划分开，那么当接收端同时想发数据和确认一个数据时，就要分两次来发数据，这样反而更浪费资源。用两个字段的话自己发送的数据就用序列号标注，确认序列号是发送方的数据。就可以在一个 TCP 数据包中完成数据的发送和确认。
    
    这样的做法被叫做捎带应答。它的基本思想是在发送数据包时捎带上对对方数据包的确认信息，从而减少单独发送确认包的次数。

在每次建立 TCP 连接时，连接双方会交换对方的序列号初始值，来同步序列号。只有同步了序列号，接收方才能正确的处理数据的接收情况和顺序，才能给发送方返回正确的应答报文。发送方接收了正确的应答报文，才能标识哪些数据包是已经被对方接收的，那些是待发送的，那些是发送但未应答的。

通常连接双方在发送 SYN 时，会随机生成一个初始序列号值，放在 TCP 报头的序列号中。每次采用随机初始序列号的目的是防止历史报文被下一个相同 TCP 连接接收。但这个方法并不能完全避免。

??? note "初始序列号的生成方式"
    初始序列号 = M + Hash(localhost, localport, remotehost, remoteport)

    M 是一个计时器，这个计时器每隔 4 微秒加 1，循环一次要 4.55 小时。

    Hash是根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。

但是在网络中传输，总会出现丢包问题，TCP 采用超时重传机制来解决丢包问题。  

### **超时重传**

丢包有两种情况：发送的数据包丢失或确认应答丢失。

超时重传顾名思义，当发送方长时间没有收到接收方的确认应答时，就要将数据进行重传。超时的时间设定很重要，如果太长可能导致无意义的等待，降低数据传输效率，太短也不行，因为 数据包 和 ACK 可能在传输时迟到，这样可能会导致数据的重复发送。

超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。RTO 通常被设置为比 RTT（Round-Trip Time 往返时延）略大一点。RTO 在内核中实现时也不是固定不变的，而是随网络动态调整的。

1. Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍。

2. 如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传。
  
3. 如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增。

4. 累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接。

## **面向连接**

### **建立连接**

TCP 建立连接要经过三次握手，首先客户端向服务器发送一个 SYN 报文，表示向服务端发起连接，与服务端同步序列号，服务器接收到该报文后会返回一个 ACK 和 SYN 表示接收到了该报文并，并且与客户端同步序列号，客户端收到该报文后再次向服务端返回确认应答，至此连接建立成功，双方可以正常通信了。

<figure markdown="span">
  ![Image title](./03.png){ width="800" }
</figure>

要注意的是：第三次握手是可以携带数据的，前两次握手是不可以携带数据的。

**重点来了，为什么建立连接需要三次握手？**

- 三次握手才能确保双方的序列号，窗口大小的同步，并且验证双方的通信信道通常。

两次握手只能保证服务器正确收到来自客户端序列号和窗口大小的同步，而不能保证客户端正确收到服务器的同步请求。

- 避免历史连接的建立

现在假设建立连接时，我们只有两次握手：

思考这样一种状况，客户端发起第一次连接时，网络阻塞了，导致第一次 SYN （后文称为 CLI_SYN1），超过了重传时间还未到达服务器，于是客户端发起重传，发出了第二次 SYN（后文称为 CLI_SYN2）。在 SYN2 发送的过程中，SYN1 到达了服务器，服务器对 SYN1 做出了回应，当客户端收到回应 ACK + SER_SYN1 时，发现收到了错误的确认序列号，向服务器发送 RST 。但是因为只有两次握手，服务器认为连接已经建立，就会直接向客户端发送数据，这导致了一个历史连接的建立。


<figure markdown="span">
  ![Image title](./04.png){ width="1000" }
</figure>

因为上述两条原因建立连接只能三次，不能两次。那为什么不用四次握手呢？

- 捎带应答

服务器对客户端的 SYN 的应答和服务器向客户端的 SYN 完全可以合并为一个数据报，一起发给客户端，这样不仅节省网络资源，效率也更高。


### **断开连接**

- 第一次挥手：当一方主动发起断开请求时，会向被动断开方发送 FIN 包，告知其断开意愿，并进入 FIN_WAIT_1 状态，等待被动断开方的 ACK 应答。

- 第二次挥手：被动断开方收到 FIN 包后返回 ACK 应答，进入 CLOSE_WAIT 状态，等待进程调用 close 关闭 socket。主动断开方收到该 ACK 应答后进入 FIN_WAIT_2 状态，等待被动断开方的 FIN 包。

- 第三次挥手：当调用 close 后，会向主动断开方发送 FIN 包，并进入 LAST_ACK 状态，等待主动断开方的 ACK 应答。
  
- 第四次挥手：主动断开方收到对方的 FIN 包后，发送 ACK 应答，并进入 TIME_WAIT 状态，等待 2MSL（Maximum Segment Lifetime，报文最大生存时间） 的时间，以确保对方收到 ACK 应答，然后进入 CLOSE 状态。对方收到 ACK 应答后进入 CLOSE 状态。


<figure markdown="span">
  ![Image title](./05.png){ width="1000" }
</figure>

至此完成连接的断开。

- **被动断开方不调用 close 会怎么样？**

内核是没有权力将进程处于 CLOSE_WAIT 的连接断开的，只能由进程自己调用 close 来断开，如果进程不调用处于 CLOSE_WAIT 的连接会在系统中存在很久，直到进程结束。

- **四次挥手可以是三次吗？**

四次挥手是有可能变为三次挥手的，那就是被动断开方在收到主动断开方的 FIN 包之前，也发起了断开请求，在收到 FIN 包后，会将 FIN 包的应答 ACK 和被动断开方的 FIN 包一起发给主动断开方（捎带应答），但是这种情况比较少见。


- **TIME_WAIT**




