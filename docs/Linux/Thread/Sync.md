
## **线程互斥**

当一个线程要对临界资源进行一些非原子性操作时，就要对该临界资源加锁，来实现在任意时刻临界区内只有一个线程在执行，这样行为被称作**线程互斥(Thread Mutex)**。

??? info "如何理解原子性"
    对于原子性操作，我们可以粗略的理解为不会被执行流的替换所打断的操作。
    
    CPU 对于硬件中断的检测是在每次指令执行结束后，而时间片结束的检测是在每次收到时钟中断后，也就是说在一条指令结束后，系统才要判断是否要进行执行流的替换，所以我们可以说一条汇编指令是原子性的。

### **互斥锁的使用**

被加锁的临界资源是不允许其他执行流进行访问的。原生线程库为我们提供了互斥锁

```cpp
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *restrict mutex,
    const pthread_mutexattr_t *restrict attr);
```

函数参数列表中的类型 `pthread_mutex_t` 称为互斥锁。定义完互斥锁后，使用函数 `pthread_mutex_init` 对互斥锁初始化，使锁变为可工作状态。锁用完之后，需要使用 `pthread_mutex_destroy` 函数销毁锁。

初始化锁还有一种静态分配的方法：

```cpp
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

使用 `PTHREAD_ MUTEX_ INITIALIZER` 初始化的互斥量不需要销毁。


初始化锁后，就要使用锁：

```cpp
#include <pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

当锁变为可用状态后，需要使用 `pthread_mutex_lock` 函数对相关线程进行加锁操作。返回值：成功返回0，失败返回错误号。一旦加锁成功，就可以继续执行对应的执行流，如果加锁失败，则会把对应执行流阻塞住。执行流完成后，需要使用 `pthread_mutex_unlock` 函数进行解锁。

使用 `pthread_mutex_trylock` 非阻塞的申请锁，如果锁被占用会继续执行下面的代码。

??? code "互斥锁"
    ```cpp
    /*
    4 个线程模拟抢票，ticket 就是临界资源
    在不同线程访问 ticket 时，就要加锁，保证线程安全
    */
    #include <pthread.h>
    #include <iostream>
    #include <string>
    using namespace std;


    int ticket = 100000;

    // ticket_mutex 也是临界资源，但是对锁的操作都是原子性的。
    pthread_mutex_t ticket_mutex = PTHREAD_MUTEX_INITIALIZER;

    void* get_ticket(void* args)
    {
        string thread_name = (char*)args;
        int* cnt = new int(0);
        for(;;)
        {
            // 线程要进入临界区，要申请锁
            pthread_mutex_lock(&ticket_mutex);
            // ============临界区===============
            if(ticket > 0)
            {
                ticket--;
                (*cnt)++;
                cout << thread_name << " get ticket ,tickets left: " << ticket << '\n';
            // ============临界区===============
                pthread_mutex_unlock(&ticket_mutex);
            }
            else
            {
                // 防止资源死锁
                pthread_mutex_unlock(&ticket_mutex);
                break;
            }
        }
        return (void*)cnt;
    }


    int main()
    {
        // 创建 4 个线程，去抢票
        pthread_t tids[4];
        for(int i = 0;i < 4;++i)
        {
            string* tid_name = new string("thread-" + to_string(i));
            pthread_create(&tids[i],nullptr,get_ticket,(void*)tid_name->c_str());
        }

        // 线程回收
        for(int i = 0;i < 4;++i)
        {
            int* res;
            pthread_join(tids[i],(void**)&res);
            cout << "thread-" + to_string(i) << " get: " << *res << '\n';
        }
        return 0;
    }
    ```

加锁操作有几点注意事项：

- 凡是访问同一个临界资源的线程，都要进行加锁保护，并且必须加同一把锁，这是规则，不能有例外。

- 在给执行流加锁时，只需要给临界区加锁就可以了。加锁的本质是让代码串行化，因此让临界区的代码越少越好，这样比较节省运行时间。

- 线程访问临界区的时候，需要先加锁，这意味着所有的线程都可以先看到同一把锁，因此锁本身就是一个公共资源，锁需要保证自己的安全。所以加锁和解锁本身就是原子性的。

- 临界区可以是一行代码，也可以是一批代码。 在执行临界区代码的时候，线程有可能会被切换，但是因为锁并没有被释放，所以其他线程都无法成功的申请到锁，会被阻塞起来。因此线程被切换不会导致资源被别的执行流更新替换。这也是互斥带来的串行化的体现。

- 对于线程而言，有意义的状态只有两种：持有锁、不持有锁，不存在其他中间状态。只有当线程的工作做完之后，才会归还锁。原子性就体现在这里。

### **互斥锁的实现原理**

为了实现互斥锁操作，大多数体系结构都提供了 swap 或 exchange 指令，该指令的作用是把寄存器和内存单元的数据相交换，由于只有一条指令，保证了原子性，即使是多处理器平台，访问内存的 总线周期也有先后，一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。

<figure markdown="span">
  ![Image title](01.png){ width="550" }
</figure>

加锁代码的 movb 指令本质上是调用线程，向自己的上下文写入 0 。 xchgb 指令本质上是将共享数据交换到自己的私有上下文中，即加锁操作，因为这里是一条汇编指令，就保证了加锁操作的原子性。假设共享资源 mutex 中存放的是 1 ，那么交换操作并没有新增任何的 1 ， 1 只会进行流转，保证了锁的唯一性。


### **常见概念**

#### **线程安全**

线程安全是指在多线程环境下，多个线程同时访问同一资源时，不会产生意外结果或导致数据出错的状态。一个线程安全的程序能够正确地处理并发请求，不论线程执行的顺序如何。

**常见线程不安全的情况：**

- 不保护共享变量的函数。

- 函数状态随着被调用，状态发生变化的函数。

- 返回指向静态变量指针的函数。

- 调用线程不安全函数的函数。

#### **可重入函数**

同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入。一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数被称为可重入函数，否则，是不可重入函数。

可重入函数一定是线程安全的，但线程安全的不一定是可重入的。

**常见可重入的情况：**

- 不使用全局变量或静态变量。

- 不使用用malloc或者new开辟出的空间。

- 不调用不可重入函数。

- 不返回静态或全局数据，所有数据都有函数的调用者提供。

- 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。

#### **死锁** 

死锁是指在一组进程中的各个线程均占有不会释放的资源，但因互相申请被其他线程所占用的不会释放的资源而处于的一种永久等待状态。

死锁四个必要条件：

- 互斥条件：一个资源每次只能被一个执行流使用。

- 请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不放。

- 不剥夺条件：一个执行流已获得的资源，在末使用完之前，不能强行剥夺。

- 循环等待条件：若干执行流之间形成一种头尾相接的循环等待资源的关系。


避免死锁的算法：**死锁检测算法，银行家算法**

## **线程同步**

线程饥饿：一个线程频繁连续的申请锁，但是申请到锁之后什么都不做。导致其他进程无法申请到锁，其他进程就处于饥饿状态。

同步：在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题，叫做同步。互斥可以保证资源的安全性，同步可以帮助我们更高效的使用的资源，而不会被单一执行流长期占用。同步的实现类似的队列，每次只能由队首位置的执行流去申请锁，当执行流释放锁以后，会回到队尾。

竞态条件：即计算的正确性取决于多个线程的交替执行时序。当多个线程或进程在没有适当同步的情况下访问和修改共享数据时，就可能出现竞态条件。这可能导致不可预测的结果，因为线程或进程的调度顺序通常是不确定的。

### **条件变量**

条件变量是利用线程间共享的变量进行同步的一种机制，在多线程程序中的表现为：当共享资源满足某种条件时，部分线程队列才会被从等待中唤醒，去申请锁。