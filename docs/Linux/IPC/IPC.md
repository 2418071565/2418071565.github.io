

## **进程间通信**

进程间通信 (InterProcess Communication，IPC)，就是进程之间进行信息交换、共享资源、事件通知以及进程间的控制等行为。

因为每个进程之间是相互独立的，所以他们想要进行通信，就要借助到操作系统。操作系统提供了多种进程间通信的方式：

- 管道
- System V IPC
- POSIX IPC


## **管道**

管道是 Unix 系统最古老的一种进程间通信方式。我们在 Unix 命令行下一定用过 `|` ，来实现将上一个命令的输出交给下一命令作为输入，例如下面的命令：

<figure markdown="span">
  ![Image title](01.png){ width="550" }
</figure>

这里 `|` 就是创建了一个匿名管道。

我们知道每个进程是相互独立的所以，不可能直接在两个进程的地址空间上互相交换数据，而是由内核提供一个媒介，上面这里管道就是一个进程数据流向另一个进程的媒介。

<figure markdown="span">
  ![Image title](02.png){ width="550" }
</figure>



### **原理**

现在思考一下，如果没有管道，我们该怎么实现将一个进程的输出交给另一个进程？

我们可以让两个进程打开同一个文件，一个以读方式，一个以写方式打开，因为同一个文件只会在内存创建一个文件对象，所以我们的写进程每次直接将数据写到文件缓冲区中，这样读进程就可以在该文件缓存区中读到写进程写入的数据。但是这样当文件缓冲区写满后，会将数据刷新到磁盘中，通信效率很低。

所以系统给我们提供了管道，管道的本质其实就是一个文件对象，但是其文件信息只存在于内存中，当管道文件被从内存中释放时，并不会将数据写入磁盘。

### **管道读写规则**

并且对于一些特殊情况，管道会比普通文件更易处理：

- 如果管道中没有数据，读端会阻塞，等待到管道中有数据为止。
- 如果管道被写满了，写端会阻塞，直到有空间后（即有数据被读端读走），才能写入。
- 写端关闭，读端读取，`read` 会返回 0。
- 读端关闭，则 `write` 操作会产生信号 `SIGPIPE`

管道还有下面的特性，便于使用：

- 字节流通信，管道中数据的读写单位是字节。
- 单向通信，要么一边读，要么一边写，不可以边读边写。
- 同步机制，读端只能按照写端写入的顺序读取数据。
- 管道声明周期随进程，进程结束，管道也会结束。


### **匿名管道**

匿名管道使用库函数 `pipe()`，可以创建一个匿名管道。

```cpp
# include<unistd.h>
int pipe(int fildes[2]);
```

该函数会创建一个文件对象作为管道，并且将读端 fd 存在 `fildes[0]` 中，写端 fd 存在 `fildes[1]` 中。

匿名管道是只存在于内存中的，完全不占据磁盘空间。并且只能让有亲缘关系的进程间进行通信，当 `fork` 得到子进程后，子进程会继承父进程该管道的两个文件描述：

<figure markdown="span">
  ![Image title](03.png){ width="550" }
</figure>

这时我们只需要按需求关闭父子进程的读写端，就可以完成父子进程的单向通信了。

<figure markdown="span">
  ![Image title](04.png){ width="550" }
</figure>

匿名管道的局限性是只能让具有亲属关系的进程间进行通信，两个毫不相关的进程无法通过继承文件描述符的方式来得到对匿名管道的读写权限，这时就需要命名管道。


### **命名管道**

命名管道的创建可以使用指令：

```shell
mkfifo [pipe_name]
```

也可也使用库函数：

```cpp
int mkfifo(const char *pathname, mode_t mode);
```

会创建一个名为 `pipe_name` 的命名管道。对于命名管道的使用就和我们上文介绍的普通文件通信的方式相同，一个进程以读方式打开，一个进程以写方式打开，但是不需要我们做强制写入。

#### **命名管道打开规则**

在管道已经存在的情况下

- 当写端未打开时，读端打开管道时会阻塞。

- 当读端未打开时，写端打开管道时也会阻塞。


## **System V 共享内存**

共享内存，顾名思义就是允许两个不相关的进程访问同一个物理内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同的进程将同一块物理内存通过页表映射到逻辑内存