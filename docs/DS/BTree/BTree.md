
## **概念**

一般的二叉查找树每个节点只能容纳一个数据，导致树的高度很高，逻辑上挨着的节点数据可能离得很远。

考虑在磁盘中存储数据的情况，与内存相比，读写磁盘有以下不同点：

1. 读写磁盘的速度相比内存读写慢很多。
2. 每次读写磁盘的单位要比读写内存的最小单位大很多。

由于读写磁盘的这个特点，因此对应的数据结构应该尽量的满足「局部性原理」：「当一个数据被用到时，其附近的数据也通常会马上被使用」，为了满足局部性原理， 所以应该将逻辑上相邻的数据在物理上也尽量存储在一起。这样才能减少读写磁盘的数量。

所以，对比起一个节点只能存储一个数据的 BST 类数据结构来，要求这种数据结构在形状上更「胖」、更加「扁平」，即：每个节点能容纳更多的数据， 这样就能降低树的高度，同时让逻辑上相邻的数据都能尽量存储在物理上也相邻的硬盘空间上，减少磁盘读写。

$B-Tree$ 是一种多路查找的平衡树。一个 $m$ 阶的 $B-Tree$ 他的一个节点中由 $m$ 个子节点和 $m - 1$ 个数据组成，且每个节点中数据有序排列，如下图是一个 $3$ 阶的 $B-Tree$：

<figure markdown="span">
  ![Image title](img/01.png){ width="550" }
</figure>

一棵 $B-Tree$ 要满足以下条件：

- 每个节点最多有 $m$ 个子节点。
- 每个非叶子节点（除根节点外），至少要有 $\left \lfloor \frac{m}{2}  \right \rfloor$ 个数据。
- 有 $k$ 个子节点的节点，有 $k-1$ 个数据元素，且元素有序排列。
- 所有的叶子节点都在同一层。


## **实现**

先来看树节点的设计：

```cpp
// Tp 数据类型，Ord B树的阶数
template<class Tp,int Ord>
struct _b_tree_node
{
    using node = _b_tree_node<Tp,Ord>;
    
    Tp      _keys[Ord];                 // 存放节点数据。
    node*   _son[Ord + 1] = { 0 };      // 存放子节点地址。
    // _keys 和 _son 都有多开一个空间，后面介绍插入时解释原因。
    node*   _fa = nullptr;              // 记录父节点
    int     _sz = 0;                    // 当前数据个数

    /* 其他成员函数 */
};
```

### **查找**

每层数据都是有序的，我们只要一层一层的去找对应的值就好。

```cpp
std::pair<node*,int> _m_find(const Tp& __k) noexcept
{
    node* fa = nullptr;
    node* cur = _m_root;
    while(cur)
    {
        // 找到第一个大于或等于 __k 的数据
        int __p;
        for(__p =  0;__p < cur->_sz ;++__p)
        {
            // 大于就
            if(__k < cur->_keys[__p])break;
            // 等于直接返回
            if(__k == cur->_keys[__p])return std::make_pair(cur,__p);
        }
        fa = cur;
        cur = cur->_son[__p];
    }
    // 到叶子节点返回 叶子 和 -1
    return std::make_pair(fa,-1);
}
```

