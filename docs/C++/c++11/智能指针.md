

## **RAII**

C++ 中在堆区申请的空间是需要程序员自行进行释放的，但是需要程序员自行约束的事情，总是会出错的，为了更好的管理堆区的内存，C++ 引入了智能指针。

智能指针是对 **RAII (Resource Acquisition Is Initialization)** 技术的实现，RAII 是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。

我们可以根据 RAII 实现一个最简单的智能指针：

```cpp
template<class Tp>
class smart_ptr
{
    Tp* _ptr;
public:
    // 实现 RAII
    smart_ptr(Tp p = nullptr)
        :_ptr(p)
    {}

    ~smart_ptr()
    { delete _ptr;}

    // 指针操作
    Tp& operator*()
    { return *_ptr;}

    Tp* operator->()
    { return _ptr;}
};
```

但只是这样还是不够的，对于指针的拷贝，还需要做很多特殊处理，如：多个智能指针指向一块空间时，应该如何避免 Double delete 等等。我们来看看 C++ 库中是如何如理的。

C++ 中提供了三种智能指针:`auto_ptr` （已弃用）、`unique_ptr`、`shared_ptr`，和一个 `weak_ptr` 来解决`shared_ptr` 循环引用的问题，后文将详细介绍。

## **`auto_ptr`**

`auto_ptr` 是在 C++98 就已经加入到标准中的，`auto_ptr` 对于指针拷贝的处理是：管理权转移，下面是 `auto_ptr` 在库中拷贝相关的实现：

```cpp
template <typename _Tp>
class auto_ptr
{
    _Tp *_M_ptr;
public:
    typedef _Tp element_type;

    /*.......*/

    // 两个拷贝都是将 __a 维护的地址交给当前的 auto_ptr并置空
    // 拷贝赋值
    auto_ptr & operator=(auto_ptr &__a) throw()
    {
        reset(__a.release());
        return *this;
    }

    // 拷贝构造
    auto_ptr(auto_ptr &__a) throw() 
        : _M_ptr(__a.release()) 
    {}

    void reset(element_type *__p = 0) throw()
    {
        // 避免自己给自己赋值导致的 double delete
        if (__p != _M_ptr)
        {
            delete _M_ptr;
            _M_ptr = __p;
        }
    }

    element_type * release() throw()
    {
        element_type *__tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
    }

    /*.......*/

};
```

我们从这个 C++98 风格的写法就可也看出，C++11 以后库就已经弃用了 `auto_ptr` ，留下源码只是为了向前兼容。为什么会弃用呢？因为这种所有权转移的处理方式会造成指针悬空：

```cpp
int main()
{
    std::auto_ptr<int> a(new int);
    std::auto_ptr<int> b (a);   // a 对数据的管理权被转移给了 b

    (*b)++;
    (*a)++; // 访问非法空间

    return 0;
}
```

这样的实现导致在 `auto_ptr` 的生命周期内，其内部数据不一定是始终有效的，很容易造成非法访问。C++11 向 `boost` 库学习，向库中加入了 `unique_ptr`、`shared_ptr`，来解决这个问题。

## **`unique_ptr`**

`unique_ptr` 的解决方案很简单，那就是禁止拷贝，我可以在库中看到：

```cpp
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
```

删除了拷贝构造和拷贝赋值。但是 `unique_ptr` 实现了移动语义，我们可以使用 `move()` 来将一个数据管理权交给另一个 `unique_ptr`，这与 `auto_ptr` 的管理权转移的处理方法类似，但更为严格，使用被 `move()` 过的变量，一般的编译器都会报警告，比起 `auto_ptr` 更为安全。但仍不是最优的方案。

## **`shared_ptr`**

`shared_ptr` 允许拷贝，它内部实现了引用计数，赋值时引用加一，指针过期时引用减一，摘掉引用计数减为零时，才释放资源，这就很好的解决了指针拷贝的问题。

```cpp
class A
{
public:
    ~A() { std::cout << "~A()" << std::endl; }
};

int main()
{
    std::shared_ptr<A> a(new A);
    // use_count() 返回当前引用该数据的指针个数，get() 返回维护的原生指针
    std::cout << "ptr count:" <<  a.use_count() 
              << " ,address:" << a.get() << std::endl;
    {
        // b 也引用 a 指向的空间，引用计数 +1
        std::shared_ptr<A> b(a);
        std::cout << "ptr count:" <<  b.use_count() 
                << " ,address:" << b.get() << std::endl;
        // b 生命周期结束，引用计数 -1
    }
    std::cout << "ptr count:" <<  a.use_count() 
              << " ,address:" << a.get() << std::endl;
    // a 生命周期结束，引用计数 -1 ，引用计数为 0 ，释放空间。
    return 0;
}
/*
输出结果：
ptr count:1 ,address:0x6f4ad0
ptr count:2 ,address:0x6f4ad0
ptr count:1 ,address:0x6f4ad0
~A()
*/
```

有了引用计数，就不需要在担心 double delete 的问题了，很好的解决了指针拷贝的问题。但是这又引出了另一个问题，**循环引用**。

### **循环引用**

什么是循环引用呢？我们拿一个例子来看：

```cpp
struct list_node
{
    int _d;
    std::shared_ptr<list_node> _nxt;
    std::shared_ptr<list_node> _pre;
public:
    
    ~list_node(){ std::cout << "~list_node()" << std::endl; }
};

int main()
{
    std::shared_ptr<list_node> node_p1(new list_node);
    std::shared_ptr<list_node> node_p2(new list_node);

    node_p1->_nxt = node_p2;
    node_p2->_pre = node_p1;

    return 0;
}
```

运行上面的代码，你会发现它是没有输出的，也就是说 `new` 来的 `list_node` 最后没有释放，内存泄漏了。那只能说明代码结束时，申请来的两个节点的引用计数还是大于 0 的。而错误就发生在两个赋值语句。

<figure markdown="span">
  ![Image title](img/04.png){ width="750" }
</figure>

这样的两个节点就构成了循环引用，这样也会导致内存泄漏，所以 C++11 还加入了 `weak_ptr` ，来解决这个问题，`weak_ptr` 是不满足 RAII 的，所以严格来说不是智能指针，他指向一个对象时，并不会增加其 `shared_ptr` 维护的引用计数，所以这里我们将节点结构体中的 `shared_ptr` 换成 `weak_ptr` 就可以避免这样的情况：

```cpp
struct list_node
{
    int _d;
    std::weak_ptr<list_node> _nxt;
    std::weak_ptr<list_node> _pre;
public:
    ~list_node(){ std::cout << "~list_node()" << std::endl; }
};
/*
输出结果：
~list_node()
~list_node()
*/
```

再运行程序，就可也正常析构节点，释放内存了。

### **`weak_ptr`**



