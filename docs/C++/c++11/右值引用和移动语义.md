

## **右值引用**

左值右值的概念在很早就以及提出了，但传统 C++98 中的引用都是左值引用，在 C++11 中才提出了右值引用的概念。但无论是左值引用还是右值引用，都是给对象起别名，底层都是指针。

### **左值和右值**

在理解右值引用前，我们先要搞懂左值和右值的是什么。

**左值 (lvalue)** 和 **右值 (rvalue)** 都是是表达式的属性。判断一个表达式是左值还是右值只要看它是否可以被取地址即可。

我们声明和定义的所有具名变量都是一个左值，它通常是有一块固定的内存空间具名对象，我们可以通过它的名称访问这块内存地址，所以它相比右值也往往有更长的生命周期。

而右值是字面常量 ( C 风格字符串除外，它表示地址 ) 、表达式返回值或是函数的返回值 ( 前提是返回值不是引用 )，它往往是代码区上的一个字面常量或是一块即将被释放空间的匿名变量对象，生命周期很短，且不具名。

```cpp
// 左值
int a = 3;
int* pa = new int(2);
const int b = 1;


int sum(int a,int b) { return a + b; }
// 常见右值
11.678          // 字面常量
nullptr         // 字面常量
10 * a          // 表达式返回值
sum(a,b)        // 函数返回值
```

### **左值引用和右值引用**

左值引用是对左值的引用，对左值取别名，当然也可也通过将引用类型加上常属性 (`const`) 来引用右值，在类型后加 `&` 就可以定义一个左值引用：

```cpp
int& lf_a = a;
int*& lf_pa = pa;
const int& lf_b = b; 
const int& lf_rval = 10;    // 常属性左值引用 引用右值
```

右值引用是对右值的引用，对右值取别名，当然也可也通过 `std::move()` 函数，将一个左值强转为右值，从而进行右值引用，这样做的意义在后文介绍，在类型后加 `&&` 就可以定义一个右值引用：

```cpp
double&& rf_d = 11.678;
int&& rf_exp = 10 * a;
int&& rf_fun = sum(a,b);
int a = 0;
int&& rf_lval = std::move(a);   // 右值引用 引用强转后的左值
```

引用的底层是指针，不管是左值引用还是右值引用本质都是一个指针常量，取地址和解引用的工作都由编译器帮我们做了，我们只需要当作变量使用就好了。但是对于字面常量，它只是代码区的一段数据，它的地址是什么？难道是代码区的一个地址吗？显然不可能是，我们看一下汇编就会发现：

<figure markdown="span">
  ![Image title](img/01.png){ width="750" }
</figure>

对于一个字面常量进行引用时，会先将其在栈区创建一个匿名变量，来存放这个值，右值引用事实上引用的是这个匿名变量。对于表达式运算结果和函数返回值 ( 返回值不能是左值引用 )，右值引用也是引用的返回结果的临时匿名对象。这事实上和**常属性左值引用**引用匿名对象是相同的，只不过左值引用是不可以修改匿名对象的，而右值引用可以。

**那么右值引用其实只做了一件事，就是提供对匿名对象的修改权限**，这样做的意义就是为了移动语义。


## **移动语义**

移动语义的目的是降低匿名对象拷贝和销毁的资源消耗。那么什么是移动语义呢？我们先来看一个初学 C++ 时一定会遇到的问题：深拷贝。以下面的类为例：

```cpp
class mstr
{
    char* p = nullptr;
    int sz = 0;
public:
    mstr(){}
    // 字符串构造
    mstr(const char* str)
    {
        sz = strlen(str);
        p = new char[sz + 1];
        memcpy(p, str, sizeof str);
    }
    // 拷贝构造
    mstr(const mstr& ot)
    {
        cout << "mstr(const mstr& ot) 深拷贝" << endl;
        if(p) delete[] p;
        p = new char[ot.sz];
        sz = ot.sz;
        memcpy(p, ot.p, ot.sz);
    }
    // 复制拷贝
    mstr& operator=(const mstr& ot)
    {
        cout << "mstr& operator=(const mstr& ot) 深拷贝" << endl;
        if(p) delete[] p;
        p = new char[ot.sz];
        sz = ot.sz;
        memcpy(p, ot.p, ot.sz);
        return *this;
    }

    ~mstr()
    { delete[] p; }

    /* 其他功能实现省略 */
};
```
我们自己的字符串类 `mstr` 在堆区申请了空间，所以在拷贝时是需要进行深拷贝的，不然在析构时会对同一块内存重复 `delete` 。

对于这样可能会在堆上申请大片空间的类，我们肯定是要尽量少创建一些无意义的匿名对象。涉及到临时变量拷贝的场景有类作为函数参数、类作为返回值，

```cpp
mstr fun(mstr a)
{
    cout << "----------------" << endl;
    mstr b;
    return b;
}
 
int main()
{
    mstr a("Hello C++11");
    mstr b;
    b = fun(a);
    return 0;
}
```

